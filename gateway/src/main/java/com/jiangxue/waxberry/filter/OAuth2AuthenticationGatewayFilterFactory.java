package com.jiangxue.waxberry.filter;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.data.redis.core.ReactiveStringRedisTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Component
public class OAuth2AuthenticationGatewayFilterFactory 
    extends AbstractGatewayFilterFactory<OAuth2AuthenticationGatewayFilterFactory.Config> {

    private static final Logger logger = LoggerFactory.getLogger(OAuth2AuthenticationGatewayFilterFactory.class);
    
    @Autowired
    private ReactiveJwtDecoder jwtDecoder;
    
    @Autowired
    private ReactiveStringRedisTemplate redisTemplate;
    
    @Autowired
    private WebClient.Builder webClientBuilder;
    
    @Autowired
    private ObjectMapper objectMapper;

    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    public OAuth2AuthenticationGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            String path = request.getURI().getPath();
            String method = request.getMethod().toString();
            
            logger.info("=== OAuth2 Filter START === {} {}", method, path);
            logger.debug("Request headers: {}", request.getHeaders().toSingleValueMap());
            
            // Ê£ÄÊü•ÊòØÂê¶Âú®ÁôΩÂêçÂçï‰∏≠
            if (isPathInWhitelist(path, config.getWhitelistPaths())) {
                logger.info("üîì Path {} is in whitelist, skipping OAuth2 authentication", path);
                return chain.filter(exchange);
            }
            
            // ÊèêÂèñ token
            String token = extractToken(request);
            if (!StringUtils.hasText(token)) {
                logger.warn("‚ùå No token found in request to: {} {}", method, path);
                logger.debug("Authorization header: {}", request.getHeaders().getFirst("Authorization"));
                logger.debug("Query params: {}", request.getQueryParams());
                return handleUnauthorized(exchange, "Missing access token");
            }
            
            logger.info("‚úÖ Token extracted successfully for: {} {}, token length: {}", method, path, token.length());
            logger.debug("Token preview: {}...{}", token.substring(0, Math.min(20, token.length())), 
                        token.length() > 20 ? token.substring(token.length() - 10) : "");
            
            // È™åËØÅ token
            return validateToken(token)
                .flatMap(isValid -> {
                    if (isValid) {
                        logger.info("‚úÖ Token validation successful for: {} {}", method, path);
                        // Token ÊúâÊïàÔºåÂÖàÊ∑ªÂä†Áî®Êà∑‰ø°ÊÅØÂà∞ËØ∑Ê±ÇÂ§¥ÔºåÁÑ∂ÂêéÁªßÁª≠ËøáÊª§Èìæ
                        ServerWebExchange modifiedExchange = addUserInfoToRequestSync(exchange, token);
                        logger.info("=== OAuth2 Filter END === {} {} - AUTHORIZED", method, path);
                        return chain.filter(modifiedExchange);
                    } else {
                        logger.warn("‚ùå Token validation failed for: {} {}", method, path);
                        return handleUnauthorized(exchange, "Invalid access token");
                    }
                })
                .onErrorResume(throwable -> {
                    logger.error("üí• Token validation error for: {} {} - {}", method, path, throwable.getMessage(), throwable);
                    return handleUnauthorized(exchange, "Token validation failed");
                });
        };
    }

    /**
     * Ê£ÄÊü•Ë∑ØÂæÑÊòØÂê¶Âú®ÁôΩÂêçÂçï‰∏≠
     */
    private boolean isPathInWhitelist(String requestPath, List<String> whitelistPaths) {
        if (whitelistPaths == null || whitelistPaths.isEmpty()) {
            return false;
        }
        
        for (String whitelistPath : whitelistPaths) {
            if (pathMatcher.match(whitelistPath, requestPath)) {
                logger.debug("‚úÖ Path {} matches whitelist pattern: {}", requestPath, whitelistPath);
                return true;
            }
        }
        
        logger.debug("‚ùå Path {} does not match any whitelist pattern", requestPath);
        return false;
    }

    private String extractToken(ServerHttpRequest request) {
        logger.debug("üîç Extracting token from request...");
        
        // ‰ªé Authorization header Ëé∑Âèñ Bearer token
        String authorization = request.getHeaders().getFirst("Authorization");
        logger.debug("Authorization header present: {}", authorization != null);
        
        if (StringUtils.hasText(authorization)) {
            logger.debug("Authorization header value: {}", authorization.substring(0, Math.min(20, authorization.length())) + "...");
            if (authorization.startsWith("Bearer ")) {
                logger.debug("‚úÖ Bearer token found in Authorization header");
                return authorization.substring(7);
            } else {
                logger.debug("‚ùå Authorization header doesn't start with 'Bearer '");
            }
        }
        
        // ‰ªé query parameter Ëé∑Âèñ token
        String tokenParam = request.getQueryParams().getFirst("access_token");
        logger.debug("Query parameter 'access_token' present: {}", tokenParam != null);
        
        if (StringUtils.hasText(tokenParam)) {
            logger.debug("‚úÖ Token found in query parameter");
            return tokenParam;
        }
        
        logger.debug("‚ùå No token found in request");
        return null;
    }

    private Mono<Boolean> validateToken(String token) {
        // ÂÖà‰ªé Redis ÁºìÂ≠ò‰∏≠Ê£ÄÊü•
        String cacheKey = "gateway:token:" + token.hashCode();
        logger.debug("üîç Checking token validation cache, key: {}", cacheKey);
        
        return redisTemplate.opsForValue().get(cacheKey)
            .cast(String.class)
            .doOnNext(cachedValue -> logger.debug("üìã Found cached validation result: {}", cachedValue))
            .map(cachedValue -> {
                boolean isValid = "valid".equals(cachedValue);
                logger.info("üíæ Using cached token validation result: {}", isValid ? "VALID" : "INVALID");
                return isValid;
            })
            .switchIfEmpty(
                // ÁºìÂ≠ò‰∏≠Ê≤°ÊúâÔºåËøõË°åÂÆûÈôÖÈ™åËØÅ
                performTokenValidation(token)
                    .doOnSubscribe(subscription -> logger.debug("üìã No cached result found, performing actual token validation"))
                    .flatMap(isValid -> {
                        // Â∞ÜÈ™åËØÅÁªìÊûúÁºìÂ≠ò
                        String cacheValue = isValid ? "valid" : "invalid";
                        logger.debug("üíæ Caching token validation result: {} for key: {}", cacheValue, cacheKey);
                        return redisTemplate.opsForValue()
                            .set(cacheKey, cacheValue, Duration.ofMinutes(5))
                            .doOnSuccess(success -> logger.debug("‚úÖ Token validation result cached successfully"))
                            .doOnError(error -> logger.error("‚ùå Failed to cache token validation result: {}", error.getMessage()))
                            .thenReturn(isValid);
                    })
            );
    }

    private Mono<Boolean> performTokenValidation(String token) {
        logger.debug("üîê Starting JWT token validation...");
        
        // ‰ΩøÁî® JWT Ëß£Á†ÅÂô®È™åËØÅ token
        return jwtDecoder.decode(token)
            .doOnSuccess(jwt -> logger.debug("‚úÖ JWT decoded successfully"))
            .map(jwt -> {
                logger.debug("üïê Checking token expiration...");
                // Ê£ÄÊü• token ÊòØÂê¶ËøáÊúü
                if (jwt.getExpiresAt() != null && jwt.getExpiresAt().isBefore(java.time.Instant.now())) {
                    logger.warn("‚ùå Token expired at: {}", jwt.getExpiresAt());
                    return false;
                }
                logger.debug("‚úÖ Token not expired, expires at: {}", jwt.getExpiresAt());
                
                // Ê£ÄÊü•ÂøÖË¶ÅÁöÑÂ£∞Êòé
                String subject = jwt.getSubject();
                logger.debug("üë§ Token subject: {}", subject);
                if (!StringUtils.hasText(subject)) {
                    logger.warn("‚ùå Token missing subject");
                    return false;
                }
                
                // ËÆ∞ÂΩïtokenÁöÑÂÖ∂‰ªñ‰ø°ÊÅØ
                logger.debug("üìù Token claims - issuer: {}, audience: {}", jwt.getIssuer(), jwt.getAudience());
                logger.info("‚úÖ Token validated successfully for user: {}", subject);
                return true;
            })
            .onErrorResume(throwable -> {
                logger.error("‚ùå JWT validation failed: {} - {}", throwable.getClass().getSimpleName(), throwable.getMessage());
                logger.debug("JWT validation error details:", throwable);
                return Mono.just(false);
            });
    }

    private ServerWebExchange addUserInfoToRequestSync(ServerWebExchange exchange, String token) {
        logger.debug("üë§ Adding user info to request headers...");
        
        try {
            Jwt jwt = jwtDecoder.decode(token).block();
            if (jwt == null) {
                logger.warn("‚ùå Failed to decode JWT for user info extraction");
                return exchange;
            }
            
            logger.debug("‚úÖ JWT decoded for user info extraction");
            
            // ‰ªé JWT ‰∏≠ÊèêÂèñÁî®Êà∑‰ø°ÊÅØÂπ∂Ê∑ªÂä†Âà∞ËØ∑Ê±ÇÂ§¥
            ServerHttpRequest.Builder requestBuilder = exchange.getRequest().mutate();
            int headerCount = 0;
            
            if (exchange.getRequest().getHeaders().getFirst("Authorization") == null) {
                requestBuilder.header("Authorization", "Bearer " + token);
                logger.debug("üìù Added Authorization header with Bearer token");
                headerCount++;
            }
            
            String username = jwt.getSubject();
            if (StringUtils.hasText(username)) {
                requestBuilder.header("X-User-Name", username);
                logger.debug("üìù Added header X-User-Name: {}", username);
                headerCount++;
            }

            String userId = jwt.getClaimAsString("userId");
            if (StringUtils.hasText(userId)) {
                requestBuilder.header("X-User-Id", userId);
                logger.debug("üìù Added header X-User-Id: {}", userId);
                headerCount++;
            }
            
            // Ê∑ªÂä†Áî®Êà∑ÊùÉÈôê‰ø°ÊÅØ
            Object scopes = jwt.getClaim("scope");
            if (scopes != null) {
                requestBuilder.header("X-User-Scopes", scopes.toString());
                logger.debug("üìù Added header X-User-Scopes: {}", scopes);
                headerCount++;
            }
            
            // ÂàõÂª∫Êñ∞ÁöÑËØ∑Ê±ÇÂíåexchange
            ServerHttpRequest newRequest = requestBuilder.build();
            logger.info("‚úÖ Successfully added {} headers (including token) to request for downstream services", headerCount);
            
            return exchange.mutate().request(newRequest).build();
            
        } catch (Exception e) {
            logger.error("‚ùå Error adding user info to request: {}", e.getMessage(), e);
            return exchange;
        }
    }

    private Mono<Void> handleUnauthorized(ServerWebExchange exchange, String message) {
        String path = exchange.getRequest().getURI().getPath();
        String method = exchange.getRequest().getMethod().toString();
        
        logger.warn("üö´ Returning 401 Unauthorized for: {} {} - {}", method, path, message);
        
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(HttpStatus.UNAUTHORIZED);
        response.getHeaders().add("Content-Type", MediaType.APPLICATION_JSON_VALUE);
        
        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("error", "unauthorized");
        errorResponse.put("message", message);
        errorResponse.put("timestamp", System.currentTimeMillis());
        errorResponse.put("path", path);
        errorResponse.put("method", method);
        
        try {
            String responseBody = objectMapper.writeValueAsString(errorResponse);
            logger.debug("üìù Unauthorized response body: {}", responseBody);
            DataBuffer buffer = response.bufferFactory().wrap(responseBody.getBytes(StandardCharsets.UTF_8));
            return response.writeWith(Mono.just(buffer));
        } catch (Exception e) {
            logger.error("‚ùå Error writing unauthorized response: {}", e.getMessage(), e);
            return response.setComplete();
        }
    }

    public static class Config {
        // ÈÖçÁΩÆÁ±ªÔºåÂèØ‰ª•Ê∑ªÂä†ÈÖçÁΩÆÂèÇÊï∞
        private boolean enabled = true;
        private List<String> whitelistPaths = new ArrayList<>();
        
        public boolean isEnabled() {
            return enabled;
        }
        
        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }
        
        public List<String> getWhitelistPaths() {
            return whitelistPaths;
        }
        
        public void setWhitelistPaths(List<String> whitelistPaths) {
            this.whitelistPaths = whitelistPaths != null ? whitelistPaths : new ArrayList<>();
        }
    }
} 
